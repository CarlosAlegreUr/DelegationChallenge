// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

/**
 * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
 * @dev @dev @dev @dev
 *
 * THIS CONTRACT HAS NOT BEEN DEVELOPERD, IT IS A
 * PLAYGROUND TO SHOWCASE THE IDEA BEHIND THE DELWRAP
 * SOLUTION
 * 
 * * all the comments in this file are just thoughts during design process
 *
 * @dev @dev @dev @dev
 * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
 */
import "../../utils/generalUtils.sol";

abstract contract delWrap {
    address public s_wrappedContract;

    // Mapps a selector from a standard to an internal function that wraps around
    // that function and adds extra logic to it.
    // Must be initialized in the constructor of the derived contract with the specifics for each
    // standard functions' selectors.
    mapping(bytes4 => bytes4) private s_ercSelectorToExtraLogic;

    modifier onlyInternalCall() {
        require(msg.sender == address(this), "Only internal calls");
        _;
    }

    constructor(address _wrappedContract) {
        s_wrappedContract = _wrappedContract;
    }

    // TO-DO: make payable an disable warning
    fallback() external /*payable*/ {
        // @dev If it matches one of the assets functions, call its wrapped version.
        // @dev If no function matches, just forward the call.
        bool success;
        bytes memory returnData;
        bytes4 extraLogicSelector = s_ercSelectorToExtraLogic[_getSelectorFromCalldata()];
        if (extraLogicSelector != bytes4(0)) {
            // TO-DO: call to extraLogicSelector
            // msg.data[0:4] + 4:the end but change 0:4 with extraLogicSelector
            (success,) = address(this).call("");
            // TO-DO: add beter error names, add IErrors interface
            require(success, "Tx failed");
        } else {
            (success, returnData) = s_wrappedContract.call(msg.data);
            require(success, "Tx failed");
            assembly {
                // to-do: generated by GPT, check if correct assembly
                return(add(returnData, 32), mload(returnData))
            }
        }
    }

    function delegateTo(address _to, bytes memory _data) external virtual;
}
